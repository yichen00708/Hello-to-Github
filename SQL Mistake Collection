1. 查找最晚入职员工的所有信息

  查找最晚入职员工的所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天
  CREATE TABLE `employees` (
  `emp_no` int(11) NOT NULL  comment '员工编号',
  `birth_date` date NOT NULL,
  `first_name` varchar(14) NOT NULL,
  `last_name` varchar(16) NOT NULL,
  `gender` char(1) NOT NULL,
  `hire_date` date NOT NULL,
  PRIMARY KEY (`emp_no`));

  solution:

  1. order by + limit
  2. ==
    SELECT * FROM employees WHERE hire_date == (SELECT MAX(hire_date) FROM employees)

2.  查找入职员工时间排名倒数第三的员工所有信息
 同上
  solution:

  1.select* from test LIMIT 1,3;
  当limit后面跟两个参数的时候，**第一个数表示要跳过的数量，后一位表示要取的数量**。???那应该是limit 2,1吧???

  2.select * from test LIMIT 3 OFFSET 1;(在mysql 5以后支持这种写法)
  当 limit和offset组合使用的时候，**limit表示要取的的数量,offset表示要跳过的数量**。


3. LC597. Friend Requests I: Overall Acceptance Rate

  #Follow-up:
  #1. Can you write a query to return the accept rate but for every month?
  #---by myself
  select a_mon, ifnull(round(acc_rate/req_rate,2),0) accept_rate
  from (select left(request_date,7) r_mon,count(distinct sender_id, send_to_id) as        req_rate
       from friend_request 
       group by r_mon) req , 

       (select left(accept_date,7) a_mon,count(distinct requester_id, accepter_id) as        acc_rate
       from request_accepted 
       group by a_mon) acc
  where req.r_mon=acc.a_mon
  
  #limits: 没有追踪到每次申请-接受的过程,单单是每月的统一数/每月的申请数 (没有考虑到 单次申请和同意不在同一个月的情况) 
      (如果先并联两个表,以接受时间为准的话,可以解决这个问题)
  #limits2:而且我觉得先GB之后再来distinct count 会有重复(比如 上个月和这个月都有同样的申请,会被重复算进两个月里)
  
  
  #2. How about the cumulative accept rate for every day?
    SELECT d
      , req_count
        , acp_count
        , SUM(req_count) OVER (ORDER BY d
            RANGE BETWEEN unbounded preceding AND current row) as cum_req_count
      , SUM(acp_count) OVER (ORDER BY d
            RANGE BETWEEN unbounded preceding AND current row) as cum_acp_count
      , round(SUM(acp_count) OVER (ORDER BY d
            RANGE BETWEEN unbounded preceding AND current row) / SUM(req_count) OVER (ORDER BY d
            RANGE BETWEEN unbounded preceding AND current row), 2) as cum_acp_rate
  FROM
    ((SELECT distinct request_date as d from friend_request) 
    UNION
    (SELECT distinct accept_date as d from request_accepted)) as all_date
    LEFT JOIN 
    (SELECT request_date, count(*) as req_count FROM (SELECT distinct request_date, sender_id,send_to_id FROM friend_request) as req_sub
    GROUP BY request_date) as req_count
    ON all_date.d = req_count.request_date
    LEFT JOIN
     (SELECT accept_date, count(*) as acp_count FROM (SELECT DISTINCT accept_date, requester_id,accepter_id FROM request_accepted) as acp_sub
     GROUP BY accept_date) as acp_count
    ON all_date.d = acp_count.accept_date
  ;
  # limit: does not consider "duplicated"
  
  
  
  
  4. lc. rank score
  
 
    with nohole as
  (select distinct(*) ss, row_number()over(order by (select null)) rank 
   from Scores
   group by score
   order by ss desc) s1
  select score, rank
  from s1, Scores
  where s1.score=Scores.score


5. lc579. Find Cumulative Salary of an Employee

  # unkonwn error in my code
  select id, month ,
          (ifnull(e1.salary,0) + ifnull(e2.salary,0) + ifnull(E3.salary,0))  as salary
  where (select id, max(month) as month
          from employee
          group by id
          HAVING COUNT(*) > 1 ) max_mon  
      left join employee e1 
      on (e1.id= max_mon.id and e1.month= max_mon.month)
      left join employee e2
      on (e1.month = e2.month +1 and e1.id=e2.id)
      left join employee e3
      on (e1.month = e3.month +2 and e1.id=e2.id)
